name: Deploy HoloWellness Chatbot to AWS

on:
  push:
    branches: [ main, master ]
  workflow_dispatch: # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      EC2_INSTANCE_ID: ${{ vars.EC2_INSTANCE_ID }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        
    - name: Install frontend dependencies
      run: |
        npm install
        
    - name: Build frontend
      run: |
        npm run build
        
    - name: Install backend dependencies
      run: |
        cd backend
        pip install -r requirements-prod.txt
        
    - name: Create deployment package
      run: |
        # Create deployment directory
        mkdir -p deployment
        
        # Copy backend files
        cp -r backend/* deployment/
        
        # Copy environment files if they exist
        [ -f ".env.production" ] && cp .env.production deployment/ || echo "⚠️  .env.production not found"
        [ -f ".env.example" ] && cp .env.example deployment/ || echo "⚠️  .env.example not found"
        
        # Copy built frontend to backend static folder
        mkdir -p deployment/static
        if [ -d "dist" ] && [ "$(ls -A dist)" ]; then
          echo "✅ Copying frontend build files from dist/ to deployment/static/"
          cp -r dist/* deployment/static/
          echo "📁 Frontend files copied:"
          ls -la deployment/static/
        else
          echo "❌ Error: dist/ folder is empty or doesn't exist after build"
          echo "🔍 Checking build output:"
          ls -la dist/ || echo "dist/ folder does not exist"
          exit 1
        fi
        
        # Copy deployment scripts
        cp -r deploy deployment/
        
        # Create deployment archive
        cd deployment
        tar -czf ../holowellness-deployment.tar.gz .
        
    # Removed S3 upload to avoid /tmp space issues on EC2 and simplify deploy
    
    - name: Resolve EC2 instance (reuse existing)
      id: resolve-ec2
      run: |
        set -e
        ID="${EC2_INSTANCE_ID}"
        if [ -z "$ID" ] || [ "$ID" = "null" ]; then
          # Fallback: find by Name tag
          ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=HoloWellness-Server" "Name=instance-state-name,Values=running,stopped" \
            --query "Reservations[].Instances[].InstanceId" --output text | head -n1)
        fi
        if [ -z "$ID" ]; then
          echo "No target EC2 instance found. Set repository variable EC2_INSTANCE_ID or tag an instance Name=HoloWellness-Server" >&2
          exit 1
        fi
        # Ensure instance is running
        aws ec2 start-instances --instance-ids "$ID" >/dev/null || true
        aws ec2 wait instance-running --instance-ids "$ID"
        
        AZ=$(aws ec2 describe-instances --instance-ids "$ID" --query 'Reservations[0].Instances[0].Placement.AvailabilityZone' --output text)
        IP=$(aws ec2 describe-instances --instance-ids "$ID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
        echo "INSTANCE_ID=$ID" >> $GITHUB_ENV
        echo "PUBLIC_IP=$IP" >> $GITHUB_ENV
        echo "AVAILABILITY_ZONE=$AZ" >> $GITHUB_ENV
        echo "instance-ip=$IP" >> $GITHUB_OUTPUT
        echo "instance-id=$ID" >> $GITHUB_OUTPUT

    - name: Push ephemeral SSH key (EC2 Instance Connect)
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        sudo apt-get update && sudo apt-get install -y openssh-client
        ssh-keygen -t rsa -b 4096 -f ~/.ssh/holowellness -N "" <<< y
        aws ec2-instance-connect send-ssh-public-key \
          --instance-id "${INSTANCE_ID}" --availability-zone "${AVAILABILITY_ZONE}" \
          --instance-os-user ubuntu \
          --ssh-public-key file://~/.ssh/holowellness.pub

    - name: Deploy Application via EC2 Instance Connect
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        # Create deployment script for remote execution
        cat > remote-deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        # Deployment package is uploaded via SCP to /home/ubuntu
        PKG=/home/ubuntu/holowellness-deployment.tar.gz
        if [ ! -f "$PKG" ]; then
            echo "❌ Deployment package not found at $PKG"; exit 1
        fi

        # Extract to application directory
        sudo mkdir -p /opt/holowellness
        sudo tar -xzf "$PKG" -C /opt/holowellness
        sudo chown -R ubuntu:ubuntu /opt/holowellness
        
        # Run application deployment (skip repository cloning since we already have the files)
        cd /opt/holowellness
        
        # Debug: Check what files are available
        echo "📦 Step 1: Repository files already available from deployment package ✅"
        echo "🔍 Debug: Contents of /opt/holowellness:"
        ls -la
        echo ""
        
        # Ensure we're in the right directory
        echo "🐍 Step 2: Setting up Python Environment..."
        echo "📁 Current directory: $(pwd)"
        
        # Backend files are directly in /opt/holowellness (not in a backend subdirectory)
        echo "✅ Backend files found directly in /opt/holowellness"
        
        # Create virtual environment in the main directory
        python3 -m venv venv
        source venv/bin/activate
        
        # Install production dependencies with CPU-only PyTorch
        pip install --upgrade pip
        pip install torch torchvision --index-url https://download.pytorch.org/whl/cpu
        pip install -r requirements-prod.txt
        
        echo "   ✅ Python environment ready"
        
        # Configure environment from GitHub Secrets/Vars → write to /opt/holowellness/.env
        echo ""
        echo "⚙️  Step 3: Configuring Environment (.env from GitHub secrets/vars)..."
        PUBIP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 || true)
        [ -z "$PUBIP" ] && PUBIP="127.0.0.1"
        OPENROUTER_MODEL_VAL="${{ vars.OPENROUTER_MODEL }}"
        [ -z "$OPENROUTER_MODEL_VAL" ] && OPENROUTER_MODEL_VAL="deepseek/deepseek-r1-distill-qwen-14b"
        CORS_EXTRA="${{ vars.CORS_EXTRA_ORIGINS }}"
        [ -n "$CORS_EXTRA" ] && CORS_EXTRA=",$CORS_EXTRA"
        SECRET_VAL="${{ secrets.SECRET_KEY }}"
        [ -z "$SECRET_VAL" ] && SECRET_VAL="holowellness-production-secret-key-2024"
        # Mitigation tuning via repo variables with safe defaults
        OPENROUTER_RETRIES_VAL="${{ vars.OPENROUTER_RETRIES }}"
        [ -z "$OPENROUTER_RETRIES_VAL" ] && OPENROUTER_RETRIES_VAL="5"
        OPENROUTER_BACKOFF_VAL="${{ vars.OPENROUTER_BACKOFF_MS }}"
        [ -z "$OPENROUTER_BACKOFF_VAL" ] && OPENROUTER_BACKOFF_VAL="1500"
        OPENROUTER_TIMEOUT_VAL="${{ vars.OPENROUTER_TIMEOUT }}"
        [ -z "$OPENROUTER_TIMEOUT_VAL" ] && OPENROUTER_TIMEOUT_VAL="60"
        OPENROUTER_MAX_TOKENS_VAL="${{ vars.OPENROUTER_MAX_TOKENS }}"
        [ -z "$OPENROUTER_MAX_TOKENS_VAL" ] && OPENROUTER_MAX_TOKENS_VAL="1000"
        DISABLE_RERANKER_VAL="${{ vars.DISABLE_RERANKER }}"
        [ -z "$DISABLE_RERANKER_VAL" ] && DISABLE_RERANKER_VAL="false"
        RAG_TIMEOUT_SECONDS_VAL="${{ vars.RAG_TIMEOUT_SECONDS }}"
        [ -z "$RAG_TIMEOUT_SECONDS_VAL" ] && RAG_TIMEOUT_SECONDS_VAL="45"

        sudo tee /opt/holowellness/.env >/dev/null <<ENVEOF
        FLASK_ENV=production
        DEBUG=False
        SECRET_KEY="${SECRET_VAL}"
        CORS_ORIGINS="http://${PUBIP},http://localhost:3000${CORS_EXTRA}"

        OPENROUTER_API_KEY="${{ secrets.OPENROUTER_API_KEY }}"
        OPENROUTER_BASE_URL="https://openrouter.ai/api/v1"
        OPENROUTER_MODEL="${OPENROUTER_MODEL_VAL}"
        OPENROUTER_MAX_TOKENS="$OPENROUTER_MAX_TOKENS_VAL"
        OPENROUTER_RETRIES="$OPENROUTER_RETRIES_VAL"
        OPENROUTER_BACKOFF_MS="$OPENROUTER_BACKOFF_VAL"
        OPENROUTER_TIMEOUT="$OPENROUTER_TIMEOUT_VAL"
        DISABLE_RERANKER="$DISABLE_RERANKER_VAL"
        RAG_TIMEOUT_SECONDS="$RAG_TIMEOUT_SECONDS_VAL"
        APP_PUBLIC_URL="http://${PUBIP}"
        APP_TITLE="HoloWellness Chatbot"

        MONGO_URI="${{ secrets.MONGO_URI }}"
        AWS_REGION="${{ secrets.AWS_REGION }}"

        LOG_LEVEL=INFO
        CACHE_TTL=3600
        MAX_CACHE_SIZE=1000
        DEFAULT_CHATBOT_ID=507f1f77bcf86cd799439011
        ENVEOF
        # Normalize: strip any leading spaces introduced by YAML indentation
        sudo sed -i 's/^\s\+//' /opt/holowellness/.env

        # Continue with the rest of the deployment
        cd /opt/holowellness
        export FLASK_ENV=production
        export OPENROUTER_API_KEY="${{ secrets.OPENROUTER_API_KEY }}"
        export MONGO_URI="${{ secrets.MONGO_URI }}"
        export OPENROUTER_MODEL="$OPENROUTER_MODEL_VAL"
        export APP_PUBLIC_URL="http://${PUBIP}"
        export APP_TITLE="HoloWellness Chatbot"
        
        # Start the Flask application with gunicorn (production WSGI server)
        echo "🚀 Starting Flask application with Gunicorn..."
        
        # Ensure we're in the correct directory
        cd /opt/holowellness
        
        # Set environment variables for the app
        export FLASK_ENV=production
        export OPENROUTER_API_KEY="${{ secrets.OPENROUTER_API_KEY }}"
        export MONGO_URI="${{ secrets.MONGO_URI }}"
        export PYTHONPATH="/opt/holowellness:$PYTHONPATH"
        export APP_PUBLIC_URL="http://${PUBIP}"
        export APP_TITLE="HoloWellness Chatbot"
        
        # Kill any existing processes on port 5000 (use 5000 instead of 80 to avoid permission issues)
        sudo fuser -k 5000/tcp || true
        
        # Create a gunicorn config for better logging
        cat > gunicorn.conf.py << 'GUNICORN_CONFIG'
        bind = "0.0.0.0:5000"
        workers = 3
        # Increase timeout to accommodate slower CPU inference
        timeout = 300
        graceful_timeout = 300
        keepalive = 5
        max_requests = 1000
        max_requests_jitter = 100
        preload_app = True
        daemon = False
        user = "ubuntu"
        group = "ubuntu"
        accesslog = "/opt/holowellness/gunicorn-access.log"
        errorlog = "/opt/holowellness/gunicorn-error.log"
        loglevel = "info"
        GUNICORN_CONFIG
        
        # Create systemd service for Gunicorn (ensures restart and boot persistence)
        sudo tee /etc/systemd/system/holowellness.service >/dev/null <<'UNITEOF'
        [Unit]
        Description=HoloWellness Gunicorn Service
        After=network-online.target
        Wants=network-online.target

        [Service]
        User=ubuntu
        Group=ubuntu
        WorkingDirectory=/opt/holowellness
        EnvironmentFile=-/opt/holowellness/.env
        ExecStart=/opt/holowellness/venv/bin/gunicorn --config /opt/holowellness/gunicorn.conf.py app:app
        Restart=always
        RestartSec=5
        TimeoutSec=300
        KillSignal=SIGQUIT
        Type=simple

        [Install]
        WantedBy=multi-user.target
        UNITEOF

        sudo systemctl daemon-reload
        sudo systemctl enable holowellness
        sudo systemctl restart holowellness

        # Add small swapfile to reduce OOM risk on small instances
        if ! sudo swapon --show | grep -q "/swapfile"; then
          echo "📦 Adding 1G swapfile to improve stability on small instances"
          sudo fallocate -l 1G /swapfile || sudo dd if=/dev/zero of=/swapfile bs=1M count=1024
          sudo chmod 600 /swapfile
          sudo mkswap /swapfile
          sudo swapon /swapfile
          if ! grep -q "/swapfile" /etc/fstab; then
            echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
          fi
        fi
        
        echo "⏳ Waiting for application to start..."
        sleep 20
        
        # Check if application is running on port 5000
        if curl -f http://localhost:5000/health > /dev/null 2>&1; then
            echo "✅ Flask application started successfully on port 5000!"
            
            # Get public IP
            PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
            
            # Configure simple nginx proxy to forward port 80 to 5000 (no heredoc to avoid YAML issues)
            if ! command -v nginx >/dev/null 2>&1; then
              sudo apt-get update
              sudo apt-get install -y nginx
            fi
            printf '%s\n' \
              'server {' \
              '    listen 80;' \
              '    server_name _;' \
              '' \
              '    # Increase timeouts for upstream to avoid 502 on slow responses' \
              '    proxy_connect_timeout 15s;' \
              '    proxy_send_timeout 310s;' \
              '    proxy_read_timeout 310s;' \
              '    send_timeout 310s;' \
              '    client_max_body_size 10m;' \
              '' \
              '    location / {' \
              '        proxy_pass http://127.0.0.1:5000;' \
              '        proxy_set_header Host $host;' \
              '        proxy_set_header X-Real-IP $remote_addr;' \
              '        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;' \
              '        proxy_set_header X-Forwarded-Proto $scheme;' \
              '        proxy_http_version 1.1;' \
              '        proxy_set_header Connection "";' \
              '        proxy_buffering off;' \
              '        proxy_request_buffering off;' \
              '        proxy_ignore_client_abort off;' \
              '    }' \
              '}' | sudo tee /etc/nginx/sites-available/holowellness > /dev/null
            
            # Enable the site and restart nginx
            sudo ln -sf /etc/nginx/sites-available/holowellness /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default
            sudo systemctl enable nginx
            sudo systemctl restart nginx
            
            echo "🌐 Application accessible at: http://$PUBLIC_IP/"
            echo "🤖 API endpoint: http://$PUBLIC_IP/api/chat"
            echo "📊 Health check: http://$PUBLIC_IP/health"
        else
            echo "❌ Flask application failed to start or not accessible"
            echo "🔍 Gunicorn error log:"
            sudo tail -n 200 /opt/holowellness/gunicorn-error.log || echo "No error log found"
            echo "🔍 Checking process status:"
            ps aux | grep gunicorn || echo "No gunicorn processes found"
            echo "🔍 Checking port 5000:"
            ss -tlnp | grep :5000 || echo "Nothing listening on port 5000"
            exit 1
        fi
        
        echo "   ✅ Application started successfully"
        EOF
        
        # Pre-clean remote disk to ensure enough free space
        ssh -i ~/.ssh/holowellness -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP} '
          set -euo pipefail
          echo "🔧 Pre-clean on remote to free disk..."
          df -h || true
          sudo rm -f /home/ubuntu/holowellness-deployment.tar.gz || true
          # Remove previous deployment to avoid duplication and free space
          sudo rm -rf /opt/holowellness || true
          sudo mkdir -p /opt/holowellness
          sudo chown ubuntu:ubuntu /opt/holowellness
          # Clean caches
          sudo apt-get clean || true
          sudo rm -rf /var/cache/apt/archives/* || true
          rm -rf ~/.cache/pip || true
          sudo rm -rf /tmp/* || true
          echo "After cleanup:"
          df -h || true
        '

        # Copy package and deployment script to remote host using EIC key
        scp -i ~/.ssh/holowellness -o StrictHostKeyChecking=no holowellness-deployment.tar.gz ubuntu@${PUBLIC_IP}:/home/ubuntu/holowellness-deployment.tar.gz
        scp -i ~/.ssh/holowellness -o StrictHostKeyChecking=no remote-deploy.sh ubuntu@${PUBLIC_IP}:/tmp/
        ssh -i ~/.ssh/holowellness -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP} "chmod +x /tmp/remote-deploy.sh && /tmp/remote-deploy.sh"
    
    - name: Health Check
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        # Wait for application to start
        sleep 30
        
        # Test health endpoint
        HEALTH_URL="http://${PUBLIC_IP}/health"
        echo "Testing health endpoint: $HEALTH_URL"
        
        for i in {1..10}; do
          if curl -f $HEALTH_URL; then
            echo "✅ Health check passed!"
            break
          else
            echo "⏳ Waiting for application to start... (attempt $i/10)"
            sleep 30
          fi
        done
    
    - name: API Smoke Test
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        CHAT_URL="http://${PUBLIC_IP}/api/chat"
        echo "Testing API endpoint: $CHAT_URL"
        curl -s -H 'Content-Type: application/json' --data '{"query":"hello"}' "$CHAT_URL" || true

    - name: Refresh EC2 Instance Connect key (for diagnostics)
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        # Re-send ephemeral SSH public key as EIC keys expire quickly
        aws ec2-instance-connect send-ssh-public-key \
          --instance-id "${INSTANCE_ID}" \
          --availability-zone "${AVAILABILITY_ZONE}" \
          --instance-os-user ubuntu \
          --ssh-public-key file://~/.ssh/holowellness.pub

    - name: Collect remote diagnostics and logs
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        mkdir -p logs
        ssh -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP} '
          set -euo pipefail
          sudo tail -n 200 /var/log/nginx/error.log > /tmp/nginx-error.log || true
          sudo tail -n 200 /var/log/nginx/access.log > /tmp/nginx-access.log || true
          tail -n 400 /opt/holowellness/gunicorn-error.log > /tmp/gunicorn-error.log || true
          ss -tlnp | grep :5000 > /tmp/ss-5000.txt || true
          ps aux | grep gunicorn > /tmp/ps-gunicorn.txt || true
          curl -s -i http://127.0.0.1:5000/health > /tmp/local-health.txt || true
        '
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/nginx-error.log logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/nginx-access.log logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/gunicorn-error.log logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/ss-5000.txt logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/ps-gunicorn.txt logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/local-health.txt logs/ || true

    - name: Upload diagnostics logs
      if: steps.resolve-ec2.outputs.instance-ip != ''
      uses: actions/upload-artifact@v4
      with:
        name: diagnostics-logs
        path: logs/
        
    - name: Deployment Summary
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        echo "🎉 Deployment completed successfully!"
        echo "📍 Instance IP: ${PUBLIC_IP}"
        echo "🔗 Health Check: http://${PUBLIC_IP}/health"
        echo "🤖 API Endpoint: http://${PUBLIC_IP}/api/chat"
        echo "🌐 Application: http://${PUBLIC_IP}/"
        
        # Save deployment info as artifact
        cat > deployment-info.txt << EOF
        Instance IP: ${PUBLIC_IP}
        Instance ID: ${INSTANCE_ID}
        Health Check: http://${PUBLIC_IP}/health
        API Endpoint: http://${PUBLIC_IP}/api/chat
        Application URL: http://${PUBLIC_IP}/
        Deployment Time: $(date)
        EOF
        
    - name: Upload deployment info
      if: steps.resolve-ec2.outputs.instance-ip != ''
      uses: actions/upload-artifact@v4
      with:
        name: deployment-info
        path: deployment-info.txt