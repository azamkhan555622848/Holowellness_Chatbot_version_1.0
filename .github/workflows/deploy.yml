name: Deploy HoloWellness Chatbot to AWS

on:
  push:
    branches: [ main, master ]
  workflow_dispatch: # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      EC2_INSTANCE_ID: ${{ vars.EC2_INSTANCE_ID }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        
    - name: Install frontend dependencies
      run: |
        npm install
        
    - name: Build frontend
      run: |
        npm run build
        
    - name: Install backend dependencies
      run: |
        cd backend
        pip install -r requirements-prod.txt
        
    - name: Create deployment package
      run: |
        # Create deployment directory
        mkdir -p deployment
        
        # Copy backend files
        cp -r backend/* deployment/
        
        # Copy environment files if they exist
        [ -f ".env.production" ] && cp .env.production deployment/ || echo "âš ï¸  .env.production not found"
        [ -f ".env.example" ] && cp .env.example deployment/ || echo "âš ï¸  .env.example not found"
        
        # Copy built frontend to backend static folder
        mkdir -p deployment/static
        if [ -d "dist" ] && [ "$(ls -A dist)" ]; then
          echo "âœ… Copying frontend build files from dist/ to deployment/static/"
          cp -r dist/* deployment/static/
          echo "ðŸ“ Frontend files copied:"
          ls -la deployment/static/
        else
          echo "âŒ Error: dist/ folder is empty or doesn't exist after build"
          echo "ðŸ” Checking build output:"
          ls -la dist/ || echo "dist/ folder does not exist"
          exit 1
        fi
        
        # Copy deployment scripts
        cp -r deploy deployment/
        
        # Create deployment archive
        cd deployment
        tar -czf ../holowellness-deployment.tar.gz .
        
    - name: Upload to S3
      run: |
        # Create S3 bucket if it doesn't exist
        aws s3 mb s3://holowellness-deployments-${{ github.run_number }} --region ${{ secrets.AWS_REGION }} || true
        
        # Upload deployment package
        aws s3 cp holowellness-deployment.tar.gz s3://holowellness-deployments-${{ github.run_number }}/
        
        echo "DEPLOYMENT_BUCKET=holowellness-deployments-${{ github.run_number }}" >> $GITHUB_ENV
    
    - name: Resolve EC2 instance (reuse existing)
      id: resolve-ec2
      run: |
        set -e
        ID="${EC2_INSTANCE_ID}"
        if [ -z "$ID" ] || [ "$ID" = "null" ]; then
          # Fallback: find by Name tag
          ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=HoloWellness-Server" "Name=instance-state-name,Values=running,stopped" \
            --query "Reservations[].Instances[].InstanceId" --output text | head -n1)
        fi
        if [ -z "$ID" ]; then
          echo "No target EC2 instance found. Set repository variable EC2_INSTANCE_ID or tag an instance Name=HoloWellness-Server" >&2
          exit 1
        fi
        # Ensure instance is running
        aws ec2 start-instances --instance-ids "$ID" >/dev/null || true
        aws ec2 wait instance-running --instance-ids "$ID"
        
        AZ=$(aws ec2 describe-instances --instance-ids "$ID" --query 'Reservations[0].Instances[0].Placement.AvailabilityZone' --output text)
        IP=$(aws ec2 describe-instances --instance-ids "$ID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
        echo "INSTANCE_ID=$ID" >> $GITHUB_ENV
        echo "PUBLIC_IP=$IP" >> $GITHUB_ENV
        echo "AVAILABILITY_ZONE=$AZ" >> $GITHUB_ENV
        echo "instance-ip=$IP" >> $GITHUB_OUTPUT
        echo "instance-id=$ID" >> $GITHUB_OUTPUT

    - name: Push ephemeral SSH key (EC2 Instance Connect)
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        sudo apt-get update && sudo apt-get install -y openssh-client
        ssh-keygen -t rsa -b 4096 -f ~/.ssh/holowellness -N "" <<< y
        aws ec2-instance-connect send-ssh-public-key \
          --instance-id "${INSTANCE_ID}" --availability-zone "${AVAILABILITY_ZONE}" \
          --instance-os-user ubuntu \
          --ssh-public-key file://~/.ssh/holowellness.pub

    - name: Deploy Application via EC2 Instance Connect
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        # Create deployment script for remote execution
        cat > remote-deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        # Install AWS CLI if not present
        if ! command -v aws &> /dev/null; then
            echo "ðŸ“¦ Installing AWS CLI..."
            sudo apt-get update
            sudo apt-get install -y awscli
        fi
        
        # Download and extract deployment package
        aws s3 cp s3://${{ env.DEPLOYMENT_BUCKET }}/holowellness-deployment.tar.gz /tmp/
        
        # Extract to application directory
        sudo mkdir -p /opt/holowellness
        sudo tar -xzf /tmp/holowellness-deployment.tar.gz -C /opt/holowellness
        sudo chown -R ubuntu:ubuntu /opt/holowellness
        
        # Run application deployment (skip repository cloning since we already have the files)
        cd /opt/holowellness
        
        # Debug: Check what files are available
        echo "ðŸ“¦ Step 1: Repository files already available from deployment package âœ…"
        echo "ðŸ” Debug: Contents of /opt/holowellness:"
        ls -la
        echo ""
        
        # Ensure we're in the right directory
        echo "ðŸ Step 2: Setting up Python Environment..."
        echo "ðŸ“ Current directory: $(pwd)"
        
        # Backend files are directly in /opt/holowellness (not in a backend subdirectory)
        echo "âœ… Backend files found directly in /opt/holowellness"
        
        # Create virtual environment in the main directory
        python3 -m venv venv
        source venv/bin/activate
        
        # Install production dependencies with CPU-only PyTorch
        pip install --upgrade pip
        pip install torch torchvision --index-url https://download.pytorch.org/whl/cpu
        pip install -r requirements-prod.txt
        
        echo "   âœ… Python environment ready"
        
        # Configure environment from GitHub Secrets/Vars â†’ write to /opt/holowellness/.env
        echo ""
        echo "âš™ï¸  Step 3: Configuring Environment (.env from GitHub secrets/vars)..."
        PUBIP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 || true)
        [ -z "$PUBIP" ] && PUBIP="127.0.0.1"
        OPENROUTER_MODEL_VAL="${{ vars.OPENROUTER_MODEL }}"
        [ -z "$OPENROUTER_MODEL_VAL" ] && OPENROUTER_MODEL_VAL="deepseek/deepseek-r1-distill-qwen-14b"
        CORS_EXTRA="${{ vars.CORS_EXTRA_ORIGINS }}"
        [ -n "$CORS_EXTRA" ] && CORS_EXTRA=",$CORS_EXTRA"
        SECRET_VAL="${{ secrets.SECRET_KEY }}"
        [ -z "$SECRET_VAL" ] && SECRET_VAL="holowellness-production-secret-key-2024"

        sudo tee /opt/holowellness/.env >/dev/null <<ENVEOF
        FLASK_ENV=production
        DEBUG=False
        SECRET_KEY="${SECRET_VAL}"
        CORS_ORIGINS="http://${PUBIP},http://localhost:3000${CORS_EXTRA}"

        OPENROUTER_API_KEY="${{ secrets.OPENROUTER_API_KEY }}"
        OPENROUTER_BASE_URL="https://openrouter.ai/api/v1"
        OPENROUTER_MODEL="${OPENROUTER_MODEL_VAL}"
        OPENROUTER_MAX_TOKENS="1200"
        OPENROUTER_RETRIES="3"
        OPENROUTER_BACKOFF_MS="1000"
        OPENROUTER_TIMEOUT="45"
        APP_PUBLIC_URL="http://${PUBIP}"
        APP_TITLE="HoloWellness Chatbot"

        MONGO_URI="${{ secrets.MONGO_URI }}"
        AWS_REGION="${{ secrets.AWS_REGION }}"

        LOG_LEVEL=INFO
        CACHE_TTL=3600
        MAX_CACHE_SIZE=1000
        DEFAULT_CHATBOT_ID=507f1f77bcf86cd799439011
        ENVEOF
        # Normalize: strip any leading spaces introduced by YAML indentation
        sudo sed -i 's/^\s\+//' /opt/holowellness/.env

        # Continue with the rest of the deployment
        cd /opt/holowellness
        export FLASK_ENV=production
        export OPENROUTER_API_KEY="${{ secrets.OPENROUTER_API_KEY }}"
        export MONGO_URI="${{ secrets.MONGO_URI }}"
        export OPENROUTER_MODEL="$OPENROUTER_MODEL_VAL"
        export APP_PUBLIC_URL="http://${PUBIP}"
        export APP_TITLE="HoloWellness Chatbot"
        
        # Start the Flask application with gunicorn (production WSGI server)
        echo "ðŸš€ Starting Flask application with Gunicorn..."
        
        # Ensure we're in the correct directory
        cd /opt/holowellness
        
        # Set environment variables for the app
        export FLASK_ENV=production
        export OPENROUTER_API_KEY="${{ secrets.OPENROUTER_API_KEY }}"
        export MONGO_URI="${{ secrets.MONGO_URI }}"
        export PYTHONPATH="/opt/holowellness:$PYTHONPATH"
        export APP_PUBLIC_URL="http://${PUBIP}"
        export APP_TITLE="HoloWellness Chatbot"
        
        # Kill any existing processes on port 5000 (use 5000 instead of 80 to avoid permission issues)
        sudo fuser -k 5000/tcp || true
        
        # Create a gunicorn config for better logging
        cat > gunicorn.conf.py << 'GUNICORN_CONFIG'
        bind = "0.0.0.0:5000"
        workers = 3
        # Increase timeout to accommodate slower CPU inference
        timeout = 300
        keepalive = 5
        max_requests = 1000
        preload_app = True
        daemon = True
        user = "ubuntu"
        group = "ubuntu"
        GUNICORN_CONFIG
        
        # Start gunicorn from the virtual environment with proper paths
        echo "ðŸ“ Current directory: $(pwd)"
        echo "ðŸ Python path: $PYTHONPATH"
        
        # Activate virtual environment and start gunicorn
        source venv/bin/activate
        python -c "import app; print('âœ… App module can be imported')" || {
            echo "âŒ Failed to import app module"
            python -c "import sys; print('Python path:', sys.path)"
            ls -la
            exit 1
        }
        
        # Start gunicorn with explicit module path and environment variables
        # Load from .env for consistency across restarts
        set -a
        [ -f /opt/holowellness/.env ] && . /opt/holowellness/.env
        set +a
        nohup env FLASK_ENV=production OPENROUTER_API_KEY="$OPENROUTER_API_KEY" OPENROUTER_MODEL="$OPENROUTER_MODEL" MONGO_URI="$MONGO_URI" venv/bin/gunicorn --config gunicorn.conf.py app:app > gunicorn.log 2>&1 &
        GUNICORN_PID=$!
        
        echo "â³ Waiting for application to start..."
        sleep 20
        
        # Check if application is running on port 5000
        if curl -f http://localhost:5000/health > /dev/null 2>&1; then
            echo "âœ… Flask application started successfully on port 5000!"
            
            # Get public IP
            PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
            
            # Configure simple nginx proxy to forward port 80 to 5000 (no heredoc to avoid YAML issues)
            printf '%s\n' \
              'server {' \
              '    listen 80;' \
              '    server_name _;' \
              '' \
              '    # Increase timeouts for upstream to avoid 502 on slow responses' \
              '    proxy_connect_timeout 60s;' \
              '    proxy_send_timeout 300s;' \
              '    proxy_read_timeout 300s;' \
              '    send_timeout 300s;' \
              '    client_max_body_size 10m;' \
              '' \
              '    location / {' \
              '        proxy_pass http://127.0.0.1:5000;' \
              '        proxy_set_header Host $host;' \
              '        proxy_set_header X-Real-IP $remote_addr;' \
              '        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;' \
              '        proxy_set_header X-Forwarded-Proto $scheme;' \
              '        proxy_http_version 1.1;' \
              '        proxy_set_header Connection "";' \
              '    }' \
              '}' | sudo tee /etc/nginx/sites-available/holowellness > /dev/null
            
            # Enable the site and restart nginx
            sudo ln -sf /etc/nginx/sites-available/holowellness /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default
            sudo systemctl restart nginx
            
            echo "ðŸŒ Application accessible at: http://$PUBLIC_IP/"
            echo "ðŸ¤– API endpoint: http://$PUBLIC_IP/api/chat"
            echo "ðŸ“Š Health check: http://$PUBLIC_IP/health"
        else
            echo "âŒ Flask application failed to start or not accessible"
            echo "ðŸ” Gunicorn logs:"
            cat gunicorn.log || echo "No log file found"
            echo "ðŸ” Checking process status:"
            ps aux | grep gunicorn || echo "No gunicorn processes found"
            echo "ðŸ” Checking port 5000:"
            ss -tlnp | grep :5000 || echo "Nothing listening on port 5000"
            exit 1
        fi
        
        echo "   âœ… Application started successfully"
        EOF
        
        # Copy and execute deployment script on remote instance using EIC key
        scp -i ~/.ssh/holowellness -o StrictHostKeyChecking=no remote-deploy.sh ubuntu@${PUBLIC_IP}:/tmp/
        ssh -i ~/.ssh/holowellness -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP} "chmod +x /tmp/remote-deploy.sh && /tmp/remote-deploy.sh"
    
    - name: Health Check
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        # Wait for application to start
        sleep 30
        
        # Test health endpoint
        HEALTH_URL="http://${PUBLIC_IP}/health"
        echo "Testing health endpoint: $HEALTH_URL"
        
        for i in {1..10}; do
          if curl -f $HEALTH_URL; then
            echo "âœ… Health check passed!"
            break
          else
            echo "â³ Waiting for application to start... (attempt $i/10)"
            sleep 30
          fi
        done
    
    - name: API Smoke Test
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        CHAT_URL="http://${PUBLIC_IP}/api/chat"
        echo "Testing API endpoint: $CHAT_URL"
        curl -s -H 'Content-Type: application/json' --data '{"query":"hello"}' "$CHAT_URL" || true

    - name: Refresh EC2 Instance Connect key (for diagnostics)
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        # Re-send ephemeral SSH public key as EIC keys expire quickly
        aws ec2-instance-connect send-ssh-public-key \
          --instance-id "${INSTANCE_ID}" \
          --availability-zone "${AVAILABILITY_ZONE}" \
          --instance-os-user ubuntu \
          --ssh-public-key file://~/.ssh/holowellness.pub

    - name: Collect remote diagnostics and logs
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        mkdir -p logs
        ssh -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP} '
          set -euo pipefail
          sudo tail -n 200 /var/log/nginx/error.log > /tmp/nginx-error.log || true
          sudo tail -n 200 /var/log/nginx/access.log > /tmp/nginx-access.log || true
          tail -n 400 /opt/holowellness/gunicorn.log > /tmp/gunicorn.log || true
          ss -tlnp | grep :5000 > /tmp/ss-5000.txt || true
          ps aux | grep gunicorn > /tmp/ps-gunicorn.txt || true
          curl -s -i http://127.0.0.1:5000/health > /tmp/local-health.txt || true
        '
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/nginx-error.log logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/nginx-access.log logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/gunicorn.log logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/ss-5000.txt logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/ps-gunicorn.txt logs/ || true
        scp -i ~/.ssh/holowellness -o IdentitiesOnly=yes -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP}:/tmp/local-health.txt logs/ || true

    - name: Upload diagnostics logs
      if: steps.resolve-ec2.outputs.instance-ip != ''
      uses: actions/upload-artifact@v4
      with:
        name: diagnostics-logs
        path: logs/
        
    - name: Deployment Summary
      if: steps.resolve-ec2.outputs.instance-ip != ''
      run: |
        echo "ðŸŽ‰ Deployment completed successfully!"
        echo "ðŸ“ Instance IP: ${PUBLIC_IP}"
        echo "ðŸ”— Health Check: http://${PUBLIC_IP}/health"
        echo "ðŸ¤– API Endpoint: http://${PUBLIC_IP}/api/chat"
        echo "ðŸŒ Application: http://${PUBLIC_IP}/"
        
        # Save deployment info as artifact
        cat > deployment-info.txt << EOF
        Instance IP: ${PUBLIC_IP}
        Instance ID: ${INSTANCE_ID}
        Health Check: http://${PUBLIC_IP}/health
        API Endpoint: http://${PUBLIC_IP}/api/chat
        Application URL: http://${PUBLIC_IP}/
        Deployment Time: $(date)
        EOF
        
    - name: Upload deployment info
      if: steps.resolve-ec2.outputs.instance-ip != ''
      uses: actions/upload-artifact@v4
      with:
        name: deployment-info
        path: deployment-info.txt